import fs from 'fs';
import path from 'path';
import type { HardhatRuntimeEnvironment } from 'hardhat/types';
import { getStorageAt, setStorageAt } from '@nomicfoundation/hardhat-network-helpers';
import { additions } from './abi-additions';

/**
 * Overwrites build artifacts to inject generated bytecode
 *
 * @param hre - hardhat runtime environment
 * @param contractName - contract name to overwrite
 * @param bytecode - bytecode to inject
 * @returns promise for completion
 */
async function overwriteArtifact(
  hre: HardhatRuntimeEnvironment,
  contractName: string,
  bytecode: string,
): Promise<void> {
  const artifact = await hre.artifacts.readArtifact(contractName);
  artifact.bytecode = bytecode;
  await hre.artifacts.saveArtifactAndDebugFile(artifact);
}

/**
 * Exports ABIs to file
 *
 * @param hre - hardhat runtime environment
 * @param contracts - contracts to export abis for
 * @returns complete
 */
async function exportABIs(hre: HardhatRuntimeEnvironment, contracts: string[]): Promise<void> {
  // Get output directory and ensure it exists
  const outputDirectory = path.resolve(hre.config.paths.root, './abi-exports');
  if (!fs.existsSync(outputDirectory)) fs.mkdirSync(outputDirectory);

  // Loop through each artifact we need to export
  await Promise.all(
    contracts.map(async (contractName) => {
      // Get the artifact
      const artifact = await hre.artifacts.readArtifact(contractName);

      // Get the ABI
      let abi = artifact.abi;

      // Check if we have any ABI merging to do
      if (Array.isArray(additions[artifact.contractName])) {
        abi = abi.concat(additions[artifact.contractName]);
      }

      if (Array.isArray(additions[`${artifact.sourceName}:${artifact.contractName}`])) {
        abi = abi.concat(additions[`${artifact.sourceName}:${artifact.contractName}`]);
      }

      // Write to destination
      const destination = path.resolve(outputDirectory, artifact.contractName) + '.json';
      await fs.promises.mkdir(path.dirname(destination), { recursive: true });
      await fs.promises.writeFile(destination, `${JSON.stringify(abi, null, 2)}\n`, { flag: 'w' });
    }),
  );
}

/**
 * Deletes exported ABIs folder
 *
 * @param hre - hardhat runtime environment
 * @returns complete
 */
function cleanExportedAbis(hre: HardhatRuntimeEnvironment) {
  const outputDirectory = path.resolve(hre.config.paths.root, './abi-exports');
  if (!fs.existsSync(outputDirectory)) return null;
  fs.rmSync(outputDirectory, { recursive: true, force: true });
  return null;
}

/**
 * Sets ERC20 token balance
 *
 * @param hre - hardhat runtime env
 * @param address - address to set balance for
 * @param token - ERC20 token to set balance of
 * @param balance - balance to set
 * @returns complete
 */
async function grantBalance(hre: HardhatRuntimeEnvironment, address: string, token: string, balance: bigint) {
  // Format balance
  const balanceFormatted = `0x${balance.toString(16).padStart(64, '0')}`;

  // Get token
  const ERC20 = await hre.ethers.getContractFactory('TestERC20');
  const erc20 = ERC20.attach(token);

  for (let i = 0; i < 1000; i += 1) {
    // Calculate storage slot
    const storageSlot = hre.ethers.utils.solidityKeccak256(
      ['uint256', 'uint256'],
      [(await hre.ethers.getSigners())[0].address, i],
    );

    // Get storage before
    const before = await getStorageAt(token, storageSlot);

    // Set storage
    await setStorageAt(token, storageSlot, balanceFormatted);

    // Check if token balance changed
    if ((await erc20.balanceOf(address)).toBigInt() === balance) break;

    // Restore storage before going to next slot
    await setStorageAt(token, storageSlot, before);
  }
}

export { overwriteArtifact, exportABIs, cleanExportedAbis, grantBalance };
